firmware/dircache.c
    dircache_init(): buffer_alloc for each d_name in the opendirs array
        * the opendirs dirs array is statically allocated, there's no
        reason the d_name in it shouldn't also;
        * reason for buffer_alloc() is probably that d_name needs to be a pointer
    dircache_load(): first buffer_alloc(0) to determine the start of buffer
        * this is in within HAVE_EEPROM_SETTINGS, the first buffer_alloc()
          is to check whether the buffer start matches the buffer start
          in the dump on disk, if it it is the dump is loaded to memory as-is,
          otherwise dircache is fully reinitialized
        * this relies on reproducable boots (identical buffer_alloc() calls) and
          determininistic buffers from buffer_alloc(). This should work with
          buflib also. In any event, it only affects HAVE_EEPROM_SETTINGS (h100?)
          and it's probably non-fatal if it doesn't work anymore
    *dircache_build(): buffer_alloc()s if the dircache size is known (e.g.
          from previous boots), otherwise audiobuf is accessed directly.
        * in the first case, the buffer size is known and allocated,
          followed by a "transparent build" (i.e. in background);
          should be easily replacable with buflib
        * in the second case, the buffer size is unknown and a foreground
          build is started; this relies on no other thread being able temop to
          run for exclusive access; not possible with current buflib
            -> need to implement some buflib_get_all() which may possibly
            resizeable/reallocable
          (see also dircache_do_rebuild())
    usage of the allocation:
        if not buffer_alloc()d, it's only temporarilly used, probably no
        concurrent access (CA) issues (that or it would be completely
        broken currently)
        if buffer_alloc()'d, then the buffer is used throughout runtime to
        allocate dircache_entry structs and the d_name member of it (separately,
        d_name is allocated as needed); access happens via dircache_root and
        offset (dirache_root+dircache_size, etc)
    considerations for compaction
        dircache.c itself can probably handle compation just fine, since
        it's using an offset-to-pointer mechanism already and keeps track
        of all sub-allocations (via dircache_entry->next etc)
        however, dircache_get_entry_ptr() exports dircache_entrys (and thus d_names)
        from the buffer to the caller for unknown time; therefore compaction
        of this buffer is not always safe :(
        Additionally, a pointer to a dircache_entry is saved in DIR_CACHED,
        every DIR_CACHED is from the opendirs array (local to dircache.c)
        and they have a busy flag; DIR_CACHED is opaque for callers (so
        no direct dircache_entry access) and d_name is copied to separately
        allocated storage
        -> this perhaps needs a
        lock, user supplied buffer to copy the entry or invalidation (need
        to analyze the callers more; only tagcache.c and playlist.c so far)
apps/dsp.c
    dsp_timestretch_enable(): buffer_alloc() on boot, and only if timestretch
        is enabled. size is fixed.
    usage:
        the buffer is used for resamping, depending on timestretch.
        resample_buf is toggled between small_resample_buf and big_resample_buf.
        It's then used only used in resample(), apparently without yield().
    compaction:
        resample() doesn't know if it's a buflib buffer or a static
        buffer, so buflib_get_data() doesn't seem possible; but the compaction
        callback can detect this and act accordingly. Since resample() doesn't
        yield no CA is expected and compation should work without much hassle.

        Alternatively small_resample_buf could be made a buflib allocation as
        well, as it's unused if timestretch is enabled. Then resample()
        could call buflib_get_data() unconditionally. However, for speed,
        small_resample_buf is allocated in IRAM so it has a downside.
        (buflib allocs from IRAM with a separate buflib_context perhaps?).
apps/filetypes.c
    filetypes_strdup(): buffer_alloc() for each call. It allocates a string
        buffer for the argument to hold a copy (i.e. like standard strdup)
        It is called from filetypes_store_plugin() and read_config(),
        each only called from filetypes_init(). It's probably called often,
        for tiny sizes, which is not ideal for buflib.
    usage:
        The buffer is used for the in-memory representation of viewers.config,
        setup at boot. the result of filetypes_strdup() is stored in
        in filetypes array. No pointers are exposed to other modules,
        except in openwith_get_name(), which is pretty safe as it's called
        by the list drawing (if it was unsafe, it could be copied into the buffer
        passed to openwith_get_name()).
    compaction:
        The filetypes array could safe the ids instead of raw pointers,
        the buffer is almost exclusively used in filetypes.c (see usage),
        so buflib_get_data() calls should work just fine. But the filetypes
        array can also walked through in the compaction callback. Compaction
        should be no issue here, but the tiny allocations are suboptimal.
apps/skin_engine.c
    theme_init_buffer(): On native targets, buffer_alloc() the skin buffer with
        a fixed size. The function is only called on boot in init(). It seems
        to be replacable by a static allocation. On application targets malloc()
        is used and thus isn't relevant for buflib.
    usage: The skin engine has it's own memory management. One can allocate
        from the skin buffer with skin_buffer_alloc() which returns a pointer
        It's then up to the skin element what happens with that, it very probably
        creates cross references (CR) into the buffer. The memory is also
        exposed to other modules, such as in the backdrop case.
        The skin buffer is reset upon theme (re)loading.
    compaction: It looks like very extensive changes are needed in the skin
        engine. Both CR and exposure to other modules are complicating
        compaction.
        This needs more looking, but for now it seems the easiest to replace
        buffer_alloc() with a static allocation.
apps/mpeg.c and apps/playback.c
    audio_init(): buffer_alloc() for a cuesheet struct (~72K!!!), depending
        on whether cuesheet support is enabled by the user. This allocation
        holds the currently active cuesheet
    usage:
        The pointer to this cuesheet is saved to the current struct mp3entry,
        and thus exported to other modules. struct cuesheet consists only of
        several arrays and there's no CR involved. The actual cuesheet is mostly
        passed to functions in cuesheet.c.
        Additionally, the skin engine draws text from the arrays in the
        cuesheet struct, however it seems to re-query the pointers before
        drawing.
    compaction: The yield()s cuesheet.c is complicating things. Allocation
        of the current cuesheet could be handled there entirely making it local
        to cuesheet.c. Other modules could work with the handle id (also
        in the mp3entry struct) and call buflib_get_data(). This way
        the drawing by the skin engine wouldn't be problematic problematic.
        However, SWCODEC works with other cuesheet structs (bufalloc()'d from
        the audio buffer) and pointers (or rather buffering handles), so
        those would need separate handling. At least the cuesheet struct is
        moveable without futher means.
apps/playlist.c
    playlist_init(): 3 buffer_alloc() for the static current playlist struct.
        playlist.indices and playlist.filenames are allocated according to the
        max_playlist_size setting, playlist.buffer is allocated according to the
        max_files_in_dir setting. playlist_init() is called only once during boot
        in init().
    usage:
        indices seems to primarily save
        the seek position into the playlist file the playlist is based off, or
        the offset into playlist.buffer in case of an in-ram playlist.
        buffer is apparently used to save filenames for in-ram playlist. It
        is only accessed as start of an array, with playlist.buffer_end_pos
        indicating the current position(as offset). Only playlist_save makes
        a copy of playlist.buffer.
        playlist.filenames saves pointers to dircache entries, which itself
        are buflib affected, but that doesn't matter here.
        indices and filenames are both exposed to other modules in
        playlist_create_ex() (if index_buffer == NULL). However, this code
        path is never executed, because the only caller calls it with
        a non-NULL index_buffer-
    compaction:
        If the unused code path in playlist_create_ex() is removed compation
        should be relatively painless with a callback. It seems bad practise
        to assign that buffers to a foreign playlist anyway.
apps/scrobbler.c
    scrobbler_init(): buffer_alloc() to alloc a cache of (string) entries,
        depending on the enable scrobbling user setting.
    usage:
        usage is straight forward. It's only used within scrobbler.c, not exposed
        and no CR. it's accessed as an array, no clever compaction for
        short strings. Over time entries are added, when the buffer is full
        it's flushed to disk.
    compaction:
        Since it's accessed as an array, compaction should be painless. No
        yield()s between access, so buflib_get_data() should work well.
